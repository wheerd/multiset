# -*- coding: utf-8 -*-
from typing import (Generic, ItemsView, Iterable, Iterator, KeysView, Mapping, Hashable,
                    MutableMapping, Optional, Set, Type, TypeVar, Union, ValuesView, overload)

from _typeshed import SupportsKeysAndGetItem

_T = TypeVar('_T')
_TElement = TypeVar('_TElement', bound=Hashable)
_OtherType = Union[Iterable[_TElement], Mapping[_TElement, int]]
_Self = TypeVar('_Self', bound='BaseMultiset')

class BaseMultiset(Mapping[_TElement, int], Generic[_TElement]):
    def __init__(self, iterable: Optional[_OtherType]=None) -> None: ...
    def __new__(cls, iterable=None): ...
    def __contains__(self, element: object) -> bool: ...
    def __getitem__(self, element: _TElement) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_TElement]: ...
    def isdisjoint(self, other: _OtherType) -> bool: ...
    def difference(self: _Self, *others: _OtherType) -> _Self: ...
    def __bool__(self) -> bool: ...
    @overload
    def __sub__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __sub__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    @overload
    def __rsub__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __rsub__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    def union(self: _Self, *others: _OtherType) -> _Self: ...
    @overload
    def __or__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __or__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    __ror__ = __or__
    def combine(self: _Self, *others: _OtherType) -> _Self: ...
    @overload
    def __add__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __add__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    __radd__ = __add__
    def intersection(self: _Self, *others: _OtherType) -> _Self: ...
    @overload
    def __and__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __and__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    __rand__ = __and__
    def symmetric_difference(self: _Self, other: _OtherType) -> _Self: ...
    @overload
    def __xor__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __xor__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    __rxor__ = __xor__
    def times(self: _Self, factor: int) -> _Self: ...
    def __mul__(self: _Self, factor: int) -> _Self: ...
    __rmul__ = __mul__
    def _issubset(self, other: _OtherType, strict: bool) -> bool: ...
    def issubset(self, other: _OtherType) -> bool: ...
    @overload
    def __le__(self, other: Set[_TElement]) -> bool: ...
    @overload
    def __le__(self, other: 'BaseMultiset[_TElement]') -> bool: ...
    @overload
    def __lt__(self, other: Set[_TElement]) -> bool: ...
    @overload
    def __lt__(self, other: 'BaseMultiset[_TElement]') -> bool: ...
    def _issuperset(self, other: _OtherType, strict: bool) -> bool: ...
    def issuperset(self, other: _OtherType) -> bool: ...
    @overload
    def __ge__(self, other: Set[_TElement]) -> bool: ...
    @overload
    def __ge__(self, other: 'BaseMultiset[_TElement]') -> bool: ...
    @overload
    def __gt__(self, other: Set[_TElement]) -> bool: ...
    @overload
    def __gt__(self, other: 'BaseMultiset[_TElement]') -> bool: ...
    def __eq__(self, other: object): ...
    def __ne__(self, other: object): ...
    def get(self, element: _TElement, default: int) -> int: ... # type: ignore
    @classmethod
    def from_elements(cls: Type[_Self], elements: Iterable[_TElement], multiplicity: int) -> _Self: ...
    def copy(self: _Self) -> _Self: ...
    def __copy__(self: _Self) -> _Self: ...
    def items(self) -> ItemsView[_TElement, int]: ...
    def distinct_elements(self) -> KeysView[_TElement]: ...
    def multiplicities(self) -> ValuesView[int]: ...

class Multiset(BaseMultiset[_TElement], MutableMapping[_TElement, int], Generic[_TElement]):
    def __setitem__(self, element: _TElement, multiplicity: int) -> None: ...
    def __delitem__(self, element: _TElement) -> None: ...
    @overload
    def update(self, *others: _OtherType) -> None: ...
    @overload
    def update(self, __m: SupportsKeysAndGetItem[_T, int], /, **kwargs: int) -> None: ...
    @overload
    def update(self, __m: Iterable[tuple[_T, int]], /, **kwargs: int) -> None: ...
    @overload
    def update(self, **kwargs: int) -> None: ...
    def union_update(self, *others: _OtherType) -> None: ...
    @overload
    def __ior__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __ior__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    def intersection_update(self, *others: _OtherType) -> None: ...
    @overload
    def __iand__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __iand__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    def difference_update(self, *others: _OtherType) -> None: ...
    @overload
    def __isub__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __isub__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    def symmetric_difference_update(self, other: _OtherType) -> None: ...
    @overload
    def __ixor__(self: _Self, other: Set[_TElement]) -> _Self: ...
    @overload
    def __ixor__(self: _Self, other: 'BaseMultiset[_TElement]') -> _Self: ...
    def times_update(self, factor: int) -> None: ...
    def __imul__(self: _Self, factor: int) -> _Self: ...
    def add(self, element: _TElement, multiplicity: int=1) -> None: ...
    def remove(self, element: _TElement, multiplicity: Optional[int]=None) -> int: ...
    def discard(self, element: _TElement, multiplicity: Optional[int]=None) -> int: ...
    def pop(self, element: _TElement, default: int) -> int: ... # type: ignore
    def setdefault(self, element: _TElement, default: int) -> int: ... # type: ignore
    def clear(self) -> None: ...

class FrozenMultiset(BaseMultiset[_TElement], Generic[_TElement]):
    def __hash__(self): ...
